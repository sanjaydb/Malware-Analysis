CFF explorer can be used
Notes/Scriptes  refrences : https://www.ixiacom.com/company/blog/debugging-malware-windbg
 
 
To know binary is 64 || 32 bits
{
  c:\>dumpbin /headers p1.exe 
}

Modules
-------
{
  >lm  -> command lists modules used in a given process
  >lmf -> to get a list of modules loaded and their file paths
  >lmv m <module_name>  -> starting inspecting modules 
  >dt ->  Dump type , command to walk through the file structure, to analyzing a PE binary
          can be used to analyze a file in memory -> packers.
  >dt *!* -> show all structures available for dump.
  >dt ntdll!* -> for ntdll module 

Inspecting PE structure 
------------------------
{
  >dt -r ntdll!_IMAGE_DOS_HEADER <base_address>  -> display address of an _IMAGE_DOS_HEADER structure "MZ"
                                    - Imp : look for e_lfanew property /value .Inicate how far from PE header starts
  >dt -o ntdlL!_IMAGE_DOS_HEADER e_lfanew <base_address> -> print the base n10 value of PE start.
                                                         -> we can get <base address> from lm output-o omits the offset cleaner lok.
                                                         -> eg.0n129
  >dt -o ntdll!_IMAGE_DOS_HEADER e_lganew 0x5434456  -> outpute_lfanew  0n129 <- n is base 10, x indicate base16
  
  Add affset of loaded module + e_lfanew = PE header by using "?" expression.
  >?0x5434456 + 0n129 = 0x54344444 
  now da that address
  >da  0x54344444  "PE"
  
  Continuing PE
  >dt -r ntdll!_IMAGE_NT_HEADERS 0x54344443  -> This recursively walks the structure and displays each property inside
  >dt ntdll!_IMAGE_NT_HEADERS OptionalHeader.AddressOfEntryPoint 0x54344444 = Entry point value 
                                                 - We can get the address with WinDbg variable called $exentry
                                                 
  >bp $exentry   -> break at entery point. 
  >g
  > now EIP value can be verfied with base address + AddressOfEntryPoint ? 0x5434456 + xvalue
  
  >!dh -s <base address> -> for more detailed information.
  >!dh  -i -> More details of importes 
  
  Now understand the API and try to understand what it dose. 
  
  IMP
  if the malware know if it been debuged , it some time go to wait state. to know the waitstate use below command  
  skip ahead by setting the argument in memory to 0, the poi() is like pointer in C, 
  referencing poi(esp+0x4) and not esp+0x4. get the value at esp+0x4
  
  >bp kernelbase!sleepex ".printf \"Application wait State: %u sec.\",poi(esp+4)/1000;.echo;ed esp+4 0x0;g"
  
  edit a dword at esp+0x4 and zero it out 
  >eb $peb+0x2 0x0 || bp $exentry "ba r 1 $peb+0x2 \"ub\";g" || ba e 1 0x5434456 <- hardware break point.
  
  
  >bp $exentry "eb $peb+0x2 0x0"   <- use this as always < antidebugging tech (calls to IsDebuggerPresent)
  
 
  
  focusing on the CreationDisposition parameter to filter out what isn't being accessed as OPEN_ONLY (0n3)
  >bp kernelbase!CreateFileW ".if(poi(esp+0x14) != 0n3){.printf \"Creating File: %mu\",poi(esp+0x4);.echo};g"
  >bp kernelbase!CreateFileA ".if(poi(esp+0x14) != 0n3){.printf \"Creating File: %mu\",poi(esp+0x4);.echo};g"

  Identifying when Malware Writes Data to a File
  >bp kernelbase!WriteFile ".printf \"Dumping file contents from 0x%p as ASCII: %ma\",poi(esp+0x8),poi(esp+0x8);.echo;g"

  Identifying when Malware Deletes Files
  >bp kernel32!DeleteFileW ".printf \"Deleting File: %mu\",poi(esp+4);.echo;g"
  >bp kernel32!DeleteFileA ".printf \"Deleting File: %ma\",poi(esp);.echo;g"
  
  Identifying when Malware Moves Files
  >bp kernel32!MoveFileExW ".printf \"File moved.\";.echo;.printf \"From: %mu\",poi(esp+0x4);.echo;.printf \"To: %mu\",poi(esp+0x8);.echo;g"
  >bp kernel32!MoveFileExA ".printf \"File moved.\";.echo;.printf \"From: %ma\",poi(esp+0x4);.echo;.printf \"To: %ma\",poi(esp+0x8);.echo;g"

  Identifying when Malware Copies Files
  >bp kernel32!CopyFileW ".printf \" Copying file: \";.echo;.printf \"\tFrom: %mu\",poi(esp+0x4);.echo;.printf \"\tTo: %mu\",poi(esp+0x8);.echo;g"
  >bp kernel32!CopyFileA ".printf \" Copying file: \";.echo;.printf \"\tFrom: %ma\",poi(esp+0x4);.echo;.printf \"\tTo: %ma\",poi(esp+0x8);.echo;g"

  Identifying when Malware Creates Registry Keys
  >bp kernel32!RegCreateKeyExA “.printf \”Creating RegKey: %ma\”,poi(esp+0x8);.echo;g”
  >bp kernel32!RegCreateKeyExW “.printf \”Creating RegKey: %mu\”,poi(esp+0x8);.echo;g”
  
  Identifying when Malware Accesses Registry Keys
  >bp kernel32!RegOpenKeyExA ".printf \"Accessed RegKey: %ma\",poi(esp+0x8);.echo;g"
  >bp kernel32!RegOpenKeyExW ".printf \"Accessed RegKey: %mu\",poi(esp+0x8);.echo;g"

  Identifying when Malware Accesses Registry Key Values
  >bp kernel32!RegQueryValueExA ".printf \"\tAccessed RegValue: %ma\",poi(esp+0x8);.echo;g"
  >bp kernel32!RegQueryValueExW ".printf \"\tAccessed RegValue: %mu\",poi(esp+0x8);.echo;g"

  Identifying when Malware Changes Registry Keys
  >bp kernel32!RegSetValueExA ".printf \"Setting RegKey %ma to value: %ma\",poi(esp+0x8),poi(esp+0x14);.echo;g"
  >bp kernel32!RegSetValueExW ".printf \"Setting RegKey %mu to value: %mu\",poi(esp+0x8),poi(esp+0x14);.echo;g"

  Identifying when Malware Creates Services
  >bp advapi32!CreateServiceA ".printf \"Creating Service: \";.echo;.printf \"\tService Name: %ma\",poi(esp+0x4);.echo;.printf \"\tDisplay Name: %ma\",poi(esp+0x8);.echo;g"
  >bp advapi32!CreateServiceW ".printf \"Creating Service: \";.echo;.printf \"\tService Name: %mu\",poi(esp+0x4);.echo;.printf \"\tDisplay Name: %mu\",poi(esp+0x8);.echo;g"

  Identifying when Malware Creates Processes
  >bp kernel32!CreateProcessW ".printf \"Creating Process: %mu\",poi(esp+0x8);.echo;g"
  >bp kernel32!CreateProcessA ".printf \"Creating Process: %ma\",poi(esp+0x8);.echo;g"

  Identifying when Malware Executes a Command
  >bp shell32!shellexecuteW ".printf\"Running Command:\";.echo;\"\tOperation: %mu\";.echo;\"\tTarget: %mu\";.echo;\"\tParams: %mu\",poi(esp+0x8),poi(esp+0xC),poi(esp+0x10);.echo;g"
  >bp shell32!shellexecuteA ".printf\"Running Command:\";.echo;\"\tOperation: %ma\";.echo;\"\tTarget: %ma\";.echo;\"\tParams: %mu\",poi(esp+0x8),poi(esp+0xC),poi(esp+0x10);.echo;g"

  >bp shell32!shellExecuteExW ".printf\"Running Command:\";.echo;\"\tOperation: %mu\";.echo;\"\tTarget: %mu\";.echo;\"\tParams: %mu\",poi(poi(esp+0x4)+0xC),poi(poi(esp+0x4)+0x10),poi(poi(esp+0x4)+0x14)
  >bp shell32!shellExecuteExA ".printf\"Running Command:\";.echo;\"\tOperation: %ma\";.echo;\"\tTarget: %ma\";.echo;\"\tParams: %ma\",poi(poi(esp+0x4)+0xC),poi(poi(esp+0x4)+0x10),poi(poi(esp+0x4)+0x14)
  
  Identifying when Malware Loads Libraries
  >bp kernel32!LoadLibraryA ".printf \"Loading LibraryA: %ma\",poi(esp+0x4);.echo;g"
  >bp kernel32!LoadLibraryW ".printf \"Loading LibraryW: %mu\",poi(esp+0x4);.echo;g"

  Identifying when Malware is Looking for Functions via GetProcAddress:
  >bp kernel32!GetProcAddress ".printf \"\t Looking up function: %ma\",poi(esp+0x8);.echo;g"

  Dumping ASCII and Unicode Strings
  >s -[l#]sa <start_address> <end_address>

  Searching for ASCII and Unicode Strings
  >s -a <start_address> <end_address> <pattern>
  >s -a 0x0 L?0x7FFFFFFF http://

  Additionally, we can search for unicode instead of ascii strings by specifying -u instead of -a.
  >s -u 0x0 L?0x7FFFFFFF http://

  We can leverage loop logic to iterate through memory and print each URL we find, obtaining the full URL.
  >.foreach (url {s –[1]a 0x0 L?0x7FFFFFFF http://}){.printf “Found URL: %ma\n”,${url}}
  >.foreach (url {s –[1]u 0x0 L?0x7FFFFFFF http://}){.printf “Found URL: %mu\n”,${url}}

  Other Interesting Searches:
  Searching for the keyword RSA

  Checking out the contents of 0x571516
  > da 0x571516

  Searching for Addresses
  >s -d <start_address> <end_address> <pattern>

  This is useful if you are trying to search the stack for references to a particular address. Here is an example searching for an arbitrary address.
  s -d esp L?0x2000 0x2798e8
  
  Dumping Executables From Memory
  .writemem <file_name> <address_start> <address_end>
  !dh -a <address> 
  

}
