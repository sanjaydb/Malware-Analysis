CFF explorer can be used

To know binary is 64 || 32 bits
{
  c:\>dumpbin /headers p1.exe 
}

Modules
-------
{
  >lm  -> command lists modules used in a given process
  >lmf -> to get a list of modules loaded and their file paths
  >lmv m <module_name>  -> starting inspecting modules 
  >dt ->  Dump type , command to walk through the file structure, to analyzing a PE binary
          can be used to analyze a file in memory -> packers.
  >dt *!* -> show all structures available for dump.
  >dt ntdll!* -> for ntdll module 

Inspecting PE structure 
------------------------
{
  >dt -r ntdll!_IMAGE_DOS_HEADER <base_address>  -> display address of an _IMAGE_DOS_HEADER structure "MZ"
                                    - Imp : look for e_lfanew property /value .Inicate how far from PE header starts
  >dt -o ntdlL!_IMAGE_DOS_HEADER e_lfanew <base_address> -> print the base n10 value of PE start.
                                                         -> we can get <base address> from lm output-o omits the offset cleaner lok.
                                                         -> eg.0n129
  >dt -o ntdll!_IMAGE_DOS_HEADER e_lganew 0x5434456  -> outpute_lfanew  0n129 <- n is base 10, x indicate base16
  
  Add affset of loaded module + e_lfanew = PE header by using "?" expression.
  >?0x5434456 + 0n129 = 0x54344444 
  now da that address
  >da  0x54344444  "PE"
  
  Continuing PE
  >dt -r ntdll!_IMAGE_NT_HEADERS 0x54344443  -> This recursively walks the structure and displays each property inside
  >dt ntdll!_IMAGE_NT_HEADERS OptionalHeader.AddressOfEntryPoint 0x54344444 = Entry point value 
                                                 - We can get the address with WinDbg variable called $exentry
                                                 
  >bp $exentry   -> break at entery point. 
  >g
  > now EIP value can be verfied with base address + AddressOfEntryPoint ? 0x5434456 + xvalue
  
  >!dh -s <base address> -> for more detailed information.
  >!dh  -i -> More details of importes 
  
  Now understand the API and try to understand what it dose. 
  
  IMP
  if the malware know if it been debuged , it some time go to wait state. to know the waitstate use below command  
  skip ahead by setting the argument in memory to 0, the poi() is like pointer in C, 
  referencing poi(esp+0x4) and not esp+0x4. get the value at esp+0x4
  
  >bp kernelbase!sleepex ".printf \"Application wait State: %u sec.\",poi(esp+4)/1000;.echo;ed esp+4 0x0;g"
  
  edit a dword at esp+0x4 and zero it out 
  >eb $peb+0x2 0x0 || bp $exentry "ba r 1 $peb+0x2 \"ub\";g" || ba e 1 0x5434456 <- hardware break point.
  
  
  >bp $exentry "eb $peb+0x2 0x0"   <- use this as always < antidebugging tech (calls to IsDebuggerPresent)
  
  focusing on the CreationDisposition parameter to filter out what isn't being accessed as OPEN_ONLY (0n3)
  >bp kernelbase!CreateFileW ".if(poi(esp+0x14) != 0n3){.printf \"Creating File: %mu\",poi(esp+0x4);.echo};g"
  >bp kernelbase!CreateFileA ".if(poi(esp+0x14) != 0n3){.printf \"Creating File: %mu\",poi(esp+0x4);.echo};g"

  Identifying when Malware Writes Data to a File
  >bp kernelbase!WriteFile ".printf \"Dumping file contents from 0x%p as ASCII: %ma\",poi(esp+0x8),poi(esp+0x8);.echo;g"

  Identifying when Malware Deletes Files
  >bp kernel32!DeleteFileW ".printf \"Deleting File: %mu\",poi(esp+4);.echo;g"
  >bp kernel32!DeleteFileA ".printf \"Deleting File: %ma\",poi(esp);.echo;g"
  
  Identifying when Malware Moves Files
  >bp kernel32!MoveFileExW ".printf \"File moved.\";.echo;.printf \"From: %mu\",poi(esp+0x4);.echo;.printf \"To: %mu\",poi(esp+0x8);.echo;g"
  >bp kernel32!MoveFileExA ".printf \"File moved.\";.echo;.printf \"From: %ma\",poi(esp+0x4);.echo;.printf \"To: %ma\",poi(esp+0x8);.echo;g"

  Identifying when Malware Copies Files
  >bp kernel32!CopyFileW ".printf \" Copying file: \";.echo;.printf \"\tFrom: %mu\",poi(esp+0x4);.echo;.printf \"\tTo: %mu\",poi(esp+0x8);.echo;g"
  >bp kernel32!CopyFileA ".printf \" Copying file: \";.echo;.printf \"\tFrom: %ma\",poi(esp+0x4);.echo;.printf \"\tTo: %ma\",poi(esp+0x8);.echo;g"

  Identifying when Malware Creates Registry Keys
  >bp kernel32!RegCreateKeyExA “.printf \”Creating RegKey: %ma\”,poi(esp+0x8);.echo;g”
  >bp kernel32!RegCreateKeyExW “.printf \”Creating RegKey: %mu\”,poi(esp+0x8);.echo;g”
  
  Identifying when Malware Accesses Registry Keys
  >bp kernel32!RegOpenKeyExA ".printf \"Accessed RegKey: %ma\",poi(esp+0x8);.echo;g"
  >bp kernel32!RegOpenKeyExW ".printf \"Accessed RegKey: %mu\",poi(esp+0x8);.echo;g"

  Identifying when Malware Accesses Registry Key Values
  >bp kernel32!RegQueryValueExA ".printf \"\tAccessed RegValue: %ma\",poi(esp+0x8);.echo;g"
  >bp kernel32!RegQueryValueExW ".printf \"\tAccessed RegValue: %mu\",poi(esp+0x8);.echo;g"

  Identifying when Malware Changes Registry Keys
  >bp kernel32!RegSetValueExA ".printf \"Setting RegKey %ma to value: %ma\",poi(esp+0x8),poi(esp+0x14);.echo;g"
  >bp kernel32!RegSetValueExW ".printf \"Setting RegKey %mu to value: %mu\",poi(esp+0x8),poi(esp+0x14);.echo;g"

  
  
}
